## C++构造函数与析构函数的调用

#### 1、构造函数的调用顺序？

按照如下顺序

1. 调用父类构造函数（多个父类按照声明顺序）
2. 根据声明顺序依次调用成员变量的构造函数
3. 执行自己的构造函数代码

构造函数会构造虚函数表指针。

#### 2、析构函数调用顺序？

与构造函数的调用顺序恰恰相反。析构函数调用一次后，虚函数表指针会被修改。

#### 3、析构函数什么情况下需要声明为虚函数？

##### 案例1：父类析构函数非虚函数，子类析构函数为虚函数

```
#include<iostream>

struct YY {
	~YY() {
		std::cout << "~YY()" << std::endl;
	}
};

struct A {
	~A() {///非虚函数，静态联编
		std::cout << "~A()" << std::endl;
	}
};

struct B :A {
	YY a;
	virtual ~B() {///子类析构函数为虚函数
		std::cout << "~B()" << std::endl;
	}
};

int main() {
	B* pB = new B();
	pB->~B();///手动调用~B()析构函数，
	//pB->~A();///无法调用
	delete pB;///调用B的析构函数,虚函数表中查找B的析构函数地址

	A* p = new B();//只调用A的析构函数，静态联编（编译时确定），无法调用到B的析构函数，VS运行奔溃
	p->~A(); ///手动调用A的析构函数
	delete p;///编译器触发A的析构函数调用
	return 0;
}
```

```
输出：
~B() ///pB->~B(); 
~YY()
~A()
~B()  ///delete pB;编译器触发~B()析构函数调用
~YY()
~A()
~A()///p->~A();
~A()///delete p; 奔溃。。。
```

结论：通过父类指针析构子类对象时，如果父类析构函数非虚函数，则无法调用子类的析构函数。

##### 案例2：父类析构函数是虚函数

```
#include<iostream>

struct YY {
	~YY() {
		std::cout << "~YY()" << std::endl;
	}
};

struct A {
	virtual ~A() {///虚函数，动态联编
		std::cout << "~A()" << std::endl;
	}
};

struct B :A {
	YY a;
	~B() {///由于父类析构函数为虚函数，子类必定也是虚函数，可以不写virtual
		std::cout << "~B()" << std::endl;
	}
};

int main() {
	B* pB = new B();
	pB->~B();///手动调用B的析构函数，虚函数表指针已经指向A
	//pB->~A();///无法调用
	delete pB;///调用A的析构函数，由于上面已经手动调用了~B()析构函数，

	A* p = new B();//
	p->~A();///调用B的析构函数,虚函数表指针会指向A
	delete p; ///调用A的析构函数
	return 0;
}
```

```
输出：
~B() ///pB->~B();手动调用B的析构函数
~YY()
~A() ///虚函数指针已经被修改成A
~A()  ///delete pB;
~B()  ///p->~A();调用B的析构函数
~YY()
~A()
~A() ///delete p;
```





